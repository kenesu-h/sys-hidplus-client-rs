use crate::{
  app::common::ClientApp,
  input::adapter::sdl::SdlAdapter,
  model::ClientModel,
  controller::ClientController,
  view::cli::CLIView
};

use iced::{
  button, Button,
  canvas::{self, Cache, Canvas, Cursor, Geometry},
  executor, Application, Clipboard, Column, Command, Container, Element, Length,
  Row,
  Subscription,
  Settings,
  Text
};
use std::collections::HashMap;

pub struct IcedApp {
  controller: ClientController,
  started: bool,
  button_states: HashMap<String, button::State>,
  latest: String
}

impl IcedApp {
  pub fn new() -> IcedApp {
    match ClientModel::new() {
      Ok(model) => {
        return IcedApp {
          controller: ClientController::new(
            model,
            Box::new(CLIView::new()),
            Box::new(SdlAdapter::new())
          ),
          button_states: HashMap::new(),
          started: false,
          latest: "".to_owned()
        }
      },
      Err(e) => panic!("{}", e)
    }
  }
}

#[derive(Debug, Clone, Copy)]
pub enum ClientMessage {
  Tick,
  Start,
  Stop,
  Exit
}

impl ClientApp for IcedApp {
  fn initialize() -> () {
    Self::run(Settings {
      antialiasing: true,
      ..Settings::default()
    });
    ()
  }
}

impl Application for IcedApp {
  type Executor = executor::Default;
  type Message = ClientMessage;
  type Flags = ();

  fn new(_flags: ()) -> (Self, Command<Self::Message>) {
    let mut app: IcedApp = IcedApp::new();
    match app.controller.initialize() {
      Ok(o) => app.latest = format!("OK: {:?}", o),
      Err(e) => app.latest = format!("ERR: {}", e)
    }
    return (
      app,
      Command::none()
    )
  }

  fn title(&self) -> String {
    return "client-rs".to_owned();
  }

  fn update(
    &mut self, message: Self::Message, _clipboard: &mut Clipboard
  ) -> Command<Self::Message> {
    match message {
      Self::Message::Tick => {
        self.controller.update();
      },
      Self::Message::Start => {
        match self.controller.start() {
          Ok(o) => self.latest = format!("OK: {}", o),
          Err(e) => self.latest = format!("ERR: {}", e)
        }
        self.started = !self.started;
      },
      Self::Message::Stop => {
        match self.controller.stop() {
          Ok(o) => self.latest = format!("OK: {}", o),
          Err(e) => self.latest = format!("ERR: {}", e)
        }
        println!("{}", self.latest);
        // self.controller.stop();
        self.started = !self.started;
      },
      Self::Message::Exit => {
        match self.controller.exit() {
          Ok(o) => self.latest = format!("OK: {}", o),
          Err(e) => self.latest = format!("ERR: {}", e)
        }
        self.started = false;
      }
    }

    return Command::none();
  }

  fn subscription(&self) -> Subscription<Self::Message> {
    return iced::time::every(std::time::Duration::from_secs_f32(1.0 / 60.0))
      .map(|_| Self::Message::Tick)
  }

  fn view(&mut self) -> Element<Self::Message> {
    let mut row: Row<ClientMessage> = Row::new()
      .width(Length::Fill)
      .height(Length::Fill)
      .padding(20);

    let mut sidebar: Column<Self::Message> = Column::new()
      .width(Length::FillPortion(3))
      .height(Length::Fill)
      .padding(20);
 
    sidebar = sidebar.push(
      {
        // Abstract this shit later
        if !self.button_states.contains_key("start") {
          self.button_states.insert("start".to_owned(), button::State::new());
        }
        match &self.started {
          true => {
            button(&mut self.button_states.get_mut("start").unwrap(), "Stop")
              .on_press(ClientMessage::Stop)
          },
          false => {
            button(&mut self.button_states.get_mut("start").unwrap(), "Start")
              .on_press(ClientMessage::Start)
          }
        }
      }
    );

    sidebar = sidebar.push(
      {
        let contains: bool = self.button_states.contains_key("exit").clone();
        /*
        if !contains {
          &mut self.button_states.insert("exit".to_owned(), button::State::new());
        }
        */
        /*
        if let contains = &self.button_states.contains_key("exit") {
          if !contains {
            &mut self.button_states.insert("exit".to_owned(), button::State::new());
          }
        }
        */
        /*
        button(&mut self.button_states.get_mut("exit").unwrap(), "Exit")
          .on_press(ClientMessage::Exit)
        */
      }
    );

    row = row.push(sidebar);

    let main: Column<Self::Message> = Column::new()
      .width(Length::FillPortion(1))
      .height(Length::Fill)
      .padding(20);

    row = row.push(main);

    return row.into();

    /*
    return Container::new(content)
      .width(Length::Fill)
      .height(Length::Fill)
      .padding(20)
      .center_x()
      .center_y()
      .into()
    */
  }
}

fn button<'a>(state: &'a mut button::State, text: &str) -> Button<'a, ClientMessage> {
  return Button::new(state, Text::new(text))
    .padding(10)
    .style(style::Button::Primary);
}

mod style {
  use iced::{button, Background, Color, Vector};

  pub enum Button {
    Primary
  }

  impl button::StyleSheet for Button {
    fn active(&self) -> button::Style {
      button::Style {
        background: Some(Background::Color(match self {
          Button::Primary => Color::from_rgb(0.11, 0.42, 0.87)
        })),
        border_radius: 12.0,
        shadow_offset: Vector::new(1.0, 1.0),
        text_color: Color::WHITE,
        ..button::Style::default()
      }
    }
  }
}
